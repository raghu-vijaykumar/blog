<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Raghu Vijaykumar</title>
    <link>https://raghu-vijaykumar.github.io/blog/</link>
    <description>Recent content on Raghu Vijaykumar</description>
    <image>
      <title>Raghu Vijaykumar</title>
      <url>https://raghu-vijaykumar.github.io/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://raghu-vijaykumar.github.io/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.127.0</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Aug 2024 17:12:35 +0000</lastBuildDate>
    <atom:link href="https://raghu-vijaykumar.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About Me</title>
      <link>https://raghu-vijaykumar.github.io/blog/about/</link>
      <pubDate>Wed, 12 Jun 2024 09:56:00 +0100</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/about/</guid>
      <description>I am a Solutions Architect with 8 years of experience, specializing in adaptive learning and collaboration. My expertise lies in software architecture, system design, and data structures and algorithms. I am passionate about mentoring and continuously improving my skills. My technical skills encompass a wide range of cloud computing platforms, including GCP and AWS, with a focus on data engineering, AI, and machine learning. I am proficient in programming with Java and Python, mobile app development using Flutter and Firebase, and various DevOps practices.</description>
    </item>
    <item>
      <title>Architectural Patterns</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/architectural-patterns/readme/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/architectural-patterns/readme/</guid>
      <description>Architectural Building Blocks API Gateway Overview An API Gateway is an API management service that acts as an intermediary between clients and backend services. It uses the API composition pattern to aggregate multiple backend services into a single API endpoint that clients interact with. This abstraction provides several key benefits:
Benefits of an API Gateway Seamless Internal Changes:
Facilitates internal system changes without impacting external API consumers. For example, it enables the splitting of a frontend service into different services for various devices without altering the external API.</description>
    </item>
    <item>
      <title>Builder Pattern</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/builder/readme/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/builder/readme/</guid>
      <description>Builder Pattern The Builder Design Pattern is a creational pattern that provides a way to construct complex objects step by step. Unlike the abstract factory pattern, the builder pattern is more about constructing a single object, rather than families of objects.
Why Use the Builder Pattern? The Builder pattern is particularly useful when:
Complex Object Construction: When an object requires multiple steps to construct, where each step may involve different parts of the object.</description>
    </item>
    <item>
      <title>Building Batch Pipelines on Google Cloud Platform</title>
      <link>https://raghu-vijaykumar.github.io/blog/posts/courses/building-batch-data-pipelines-gcp/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/posts/courses/building-batch-data-pipelines-gcp/</guid>
      <description>Introduction to Building Batch Data Pipelines Batch Pipelines Overview Definition: Pipelines that process a fixed amount of data and terminate.
Example: Daily processing of financial transactions to balance books and store reconciled data. ETL vs ELT:
ELT (Extract, Load, Transform):
Load raw data into a target system and perform transformations on the fly as needed. Suitable when transformations depend on user needs or view requirements (e.g., raw data accessible through views).</description>
    </item>
    <item>
      <title>Design Patterns</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/readme/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/readme/</guid>
      <description>Design Patterns Before we get to the design patterns themselves, there is just one more piece of housekeeping that I wanted to mention, and that is to do with the so-called Gamma categorization.
Typically, in design pattern literature, regardless of which language of design patterns we are talking about, we split all the design patterns into several different categories. These categories are often called Gamma categorization, named after Erich Gamma, one of the authors of the original Gang of Four book that uses C++ and Smalltalk.</description>
    </item>
    <item>
      <title>Ensuring Resiliency: High Availability and Disaster Recovery Strategies</title>
      <link>https://raghu-vijaykumar.github.io/blog/posts/architecture/how-to-ha-and-dr/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/posts/architecture/how-to-ha-and-dr/</guid>
      <description>High Availability (HA) and Disaster Recovery (DR) are critical strategies in cloud computing to ensure services are continuously available and resilient against failures.
Designing HA &amp;amp; DR Most of the services can be differentiated as compute and storage; these are the two key components when building resilient software architectures. Here is a generic diagram for HA and DR.
HA Key Components Auto-Scaling: Adjusts the number of instances based on traffic demands.</description>
    </item>
    <item>
      <title>Enterprise Product - Things to consider</title>
      <link>https://raghu-vijaykumar.github.io/blog/posts/architecture/enterprise-product/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/posts/architecture/enterprise-product/</guid>
      <description>Developing an enterprise product is a complex endeavour that demands meticulous planning and execution. Here&amp;rsquo;s a comprehensive checklist that can serve as your roadmap to success. Whether you&amp;rsquo;re launching a web server or a multifaceted application, these steps are critical for ensuring business continuity
Business Case Business Need is defined Product architecture and high level technical architecture is determined High-level technical plan is devised Estimated Budgets allocated Migration strategy, if applicable, is established Service Delivery Procedures are determined Necessary resources assigned Definite Commitment to technical and security standards established.</description>
    </item>
    <item>
      <title>Product Template - Documentation</title>
      <link>https://raghu-vijaykumar.github.io/blog/posts/architecture/product-template/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/posts/architecture/product-template/</guid>
      <description>Tech Product Documentation Template serves as a comprehensive framework for organizing and communicating essential information about a technology product. It provides a structured approach to capturing the product&amp;rsquo;s purpose, functionality, technical specifications, and operational requirements. This documentation not only outlines how the product works but also guides users on its installation, configuration, and usage.
By detailing everything from system requirements and architecture to deployment procedures and support channels, this template ensures that stakeholders from developers and IT teams to end-users and managers have a clear understanding of the product&amp;rsquo;s capabilities and how to interact with it effectively.</description>
    </item>
    <item>
      <title>Solid Principles</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/solid-principles/readme/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/solid-principles/readme/</guid>
      <description>Solid Principles Single Responsibility Principle (SRP) The Single Responsibility Principle (SRP) is one of the five SOLID principles of object-oriented design and programming. It states that a class, module, or function should have only one reason to change, meaning it should have only one responsibility or job. This principle promotes the idea that a class should only have one reason to exist, encapsulating all the functionality related to that responsibility.</description>
    </item>
    <item>
      <title>Sponsor</title>
      <link>https://raghu-vijaykumar.github.io/blog/sponsor/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/sponsor/</guid>
      <description>Whatsapp Pay </description>
    </item>
    <item>
      <title>System Design</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/readme/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/readme/</guid>
      <description>Understanding the Importance of System Design in Software Engineering System design is essential in software engineering because it ensures that software systems are scalable, reliable, maintainable, performant, cost-effective, secure, adaptable, and user-friendly. By investing time and effort into designing robust and efficient systems, organizations can build high-quality software products that meet the needs of their users and stakeholders.
Requirements Gathering, Classifying, and Analyzing Purpose:
Determine what needs to be built for the client.</description>
    </item>
    <item>
      <title>Using Ollama for Note Generation Locally</title>
      <link>https://raghu-vijaykumar.github.io/blog/posts/data-science/ollama-note-generation/</link>
      <pubDate>Fri, 23 Aug 2024 17:12:35 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/posts/data-science/ollama-note-generation/</guid>
      <description>Desc Text.</description>
    </item>
  </channel>
</rss>
