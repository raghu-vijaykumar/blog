<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DSA - Two Pointer Approach - (In Progress) | Raghu Vijaykumar</title>
<meta name=keywords content="algorithms,data-structures,two-pointer,DSA,array"><meta name=description content="The two-pointer approach is a powerful technique used to solve problems involving arrays or strings. Here are the key characteristics and criteria to identify if a problem can be effectively solved using the two-pointer approach:
Characteristics of Two-Pointer Problems Sorted Input:
The input array is sorted or can be easily sorted. Sorting often simplifies the problem and makes the two-pointer technique applicable. Finding Pairs or Subarrays:
The problem involves finding pairs, triplets, or subarrays that satisfy specific conditions, such as a target sum."><meta name=author content="Me"><link rel=canonical href=https://raghu-vijaykumar.github.io/blog/posts/dsa/two-pointer/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.822fdf31f1a1d84e83043e3faecf43e6dbfa4ac397aa562252d0d5418304799a.css integrity="sha256-gi/fMfGh2E6DBD4/rs9D5tv6SsOXqlYiUtDVQYMEeZo=" rel="preload stylesheet" as=style><link rel=icon href=https://raghu-vijaykumar.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://raghu-vijaykumar.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://raghu-vijaykumar.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://raghu-vijaykumar.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://raghu-vijaykumar.github.io/blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://raghu-vijaykumar.github.io/blog/posts/dsa/two-pointer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="DSA - Two Pointer Approach - (In Progress)"><meta property="og:description" content="The two-pointer approach is a powerful technique used to solve problems involving arrays or strings. Here are the key characteristics and criteria to identify if a problem can be effectively solved using the two-pointer approach:
Characteristics of Two-Pointer Problems Sorted Input:
The input array is sorted or can be easily sorted. Sorting often simplifies the problem and makes the two-pointer technique applicable. Finding Pairs or Subarrays:
The problem involves finding pairs, triplets, or subarrays that satisfy specific conditions, such as a target sum."><meta property="og:type" content="article"><meta property="og:url" content="https://raghu-vijaykumar.github.io/blog/posts/dsa/two-pointer/"><meta property="og:image" content="https://raghu-vijaykumar.github.io/blog/cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-27T10:06:10+01:00"><meta property="article:modified_time" content="2024-06-27T10:06:10+01:00"><meta property="og:site_name" content="Raghu Vijaykumar"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://raghu-vijaykumar.github.io/blog/cover.png"><meta name=twitter:title content="DSA - Two Pointer Approach - (In Progress)"><meta name=twitter:description content="The two-pointer approach is a powerful technique used to solve problems involving arrays or strings. Here are the key characteristics and criteria to identify if a problem can be effectively solved using the two-pointer approach:
Characteristics of Two-Pointer Problems Sorted Input:
The input array is sorted or can be easily sorted. Sorting often simplifies the problem and makes the two-pointer technique applicable. Finding Pairs or Subarrays:
The problem involves finding pairs, triplets, or subarrays that satisfy specific conditions, such as a target sum."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://raghu-vijaykumar.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"DSA - Two Pointer Approach - (In Progress)","item":"https://raghu-vijaykumar.github.io/blog/posts/dsa/two-pointer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DSA - Two Pointer Approach - (In Progress)","name":"DSA - Two Pointer Approach - (In Progress)","description":"The two-pointer approach is a powerful technique used to solve problems involving arrays or strings. Here are the key characteristics and criteria to identify if a problem can be effectively solved using the two-pointer approach:\nCharacteristics of Two-Pointer Problems Sorted Input:\nThe input array is sorted or can be easily sorted. Sorting often simplifies the problem and makes the two-pointer technique applicable. Finding Pairs or Subarrays:\nThe problem involves finding pairs, triplets, or subarrays that satisfy specific conditions, such as a target sum.","keywords":["algorithms","data-structures","two-pointer","DSA","array"],"articleBody":" The two-pointer approach is a powerful technique used to solve problems involving arrays or strings. Here are the key characteristics and criteria to identify if a problem can be effectively solved using the two-pointer approach:\nCharacteristics of Two-Pointer Problems Sorted Input:\nThe input array is sorted or can be easily sorted. Sorting often simplifies the problem and makes the two-pointer technique applicable. Finding Pairs or Subarrays:\nThe problem involves finding pairs, triplets, or subarrays that satisfy specific conditions, such as a target sum. Linear or Quadratic Time Complexity:\nThe problem can be solved in linear (O(n)) or quadratic (O(n^2)) time complexity, which are typical of two-pointer solutions. Bidirectional Traversal:\nThe solution requires traversing the array from both ends towards the center (or from the start towards the end using two pointers). Common Scenarios for Two-Pointer Approach Sum of Two Numbers:\nProblems where you need to find two numbers in an array that add up to a specific target. def twoSum(nums, target): nums.sort() left, right = 0, len(nums) - 1 while left \u003c right: total = nums[left] + nums[right] if total == target: return [left, right] elif total \u003c target: left += 1 else: right -= 1 Palindrome Checking:\nProblem: Check if a string is a palindrome by comparing characters from both ends towards the center.\ndef isPalindrome(s): left, right = 0, len(s) - 1 while left \u003c right: if s[left] != s[right]: return False left += 1 right -= 1 return True Merging Sorted Arrays Problem: Merge two sorted arrays into one sorted array. def merge(nums1, nums2): i, j = 0, 0 result = [] while i \u003c len(nums1) and j \u003c len(nums2): if nums1[i] \u003c nums2[j]: result.append(nums1[i]) i += 1 else: result.append(nums2[j]) j += 1 result.extend(nums1[i:]) result.extend(nums2[j:]) return result Finding Subarrays with Specific Conditions Problem: Find subarrays that satisfy certain conditions, such as a sum or product within a range. def subarraySum(nums, target): left, right, total = 0, 0, 0 while right \u003c len(nums): total += nums[right] right += 1 while total \u003e target: total -= nums[left] left += 1 if total == target: return [left, right - 1] Steps to Identify and Apply the Two-Pointer Approach Check if Sorting Helps Determine if sorting the array can simplify the problem: If the array is already sorted or can be sorted with (O(n \\log n)) complexity, the two-pointer approach might be applicable. Look for Pair or Subarray Problems Identify if the problem involves finding pairs, triplets, or subarrays with specific properties: Typical examples include finding pairs that sum to a target, triplets that sum to zero, or the longest subarray with a given condition. Consider the Traversal Directions Determine if moving pointers inward from both ends or outward from the start can help find the solution: Check if you can eliminate impossible solutions by moving pointers in a structured manner. Plan Pointer Movements Define the conditions for moving the left and right pointers: For instance, if the current sum is less than the target, move the left pointer right to increase the sum. If the current sum is greater than the target, move the right pointer left to decrease the sum. Additional Considerations for Two-Pointer Approaches Edge Cases Always consider edge cases such as empty arrays, arrays with only one element, or arrays where all elements are identical. These cases might affect how you initialize and move the pointers.\nMultiple Pointers In some problems, especially those involving more complex conditions or more than two pointers (e.g., three pointers for k-Sum problems), adapting the basic two-pointer technique might be necessary.\nExample: 3-Sum Problem Problem: Given an array nums of n integers, find all unique triplets (a, b, c) in the array such that they add up to zero.\ndef threeSum(nums): nums.sort() # Step 1: Sort the array res = [] for i in range(len(nums) - 2): # Step 2: Iterate through the array if i \u003e 0 and nums[i] == nums[i - 1]: # Skip duplicate values continue left, right = i + 1, len(nums) - 1 # Step 3: Initialize two pointers while left \u003c right: total = nums[i] + nums[left] + nums[right] # Calculate the sum of the triplet if total == 0: res.append([nums[i], nums[left], nums[right]]) # Add the triplet to the result # Step 4: Move pointers and skip duplicates while left \u003c right and nums[left] == nums[left + 1]: left += 1 while left \u003c right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total \u003c 0: left += 1 # Move the left pointer to the right to increase the sum else: right -= 1 # Move the right pointer to the left to decrease the sum return res Sorting: Sort the array nums first to facilitate easier triplet sum calculation and skip duplicates.\nIterating Through the Array: Use a loop to iterate through the array nums, fixing one element (nums[i]) at a time as the potential first element of the triplet.\nInitializing Pointers: For each fixed element nums[i], initialize two pointers (left and right) to find the remaining two elements (nums[left] and nums[right]).\nCalculating Triplet Sum: Calculate the sum total = nums[i] + nums[left] + nums[right]. Depending on whether total is equal to, less than, or greater than zero, adjust the pointers to find the next potential triplet.\nHandling Duplicates: Skip over duplicate values of nums[i], nums[left], and nums[right] to ensure each triplet in the result res is unique.\nMoving Pointers: Adjust left and right pointers based on the calculated total to ensure progress towards finding all possible triplets that sum to zero.\nGiven input array nums = [-1, 0, 1, 2, -1, -4], the function threeSum(nums) will find all unique triplets (a, b, c) such that a + b + c = 0, resulting in: [[-1, -1, 2], [-1, 0, 1]]\nArray Modification Be cautious when modifying the array during traversal, as it might affect subsequent pointer movements and the correctness of the solution. Make sure modifications are carefully handled.\nExample: Remove Duplicates from Sorted Array Problem: Given a sorted array nums, remove the duplicates in-place such that each element appears only once and return the new length.\ndef removeDuplicates(nums): if not nums: return 0 slow = 0 for fast in range(1, len(nums)): if nums[fast] != nums[slow]: slow += 1 nums[slow] = nums[fast] return slow + 1 Initialization: Initialize two pointers, slow and fast, where slow points to the last unique element found and fast iterates through the array. Iterate through the array: Start iterating fast from the second element (range(1, len(nums))). Compare each element with the element at slow. Modify array in-place: If nums[fast] is different from nums[slow], increment slow and update nums[slow] with nums[fast]. This modifies the array in-place to remove duplicates. Return the new length: After iterating through the array, slow + 1 gives the length of the array with unique elements. This example demonstrates modifying the array (nums) in-place while using two pointers (slow and fast) to efficiently remove duplicates.\nTime Complexity Analysis While the two-pointer approach often provides efficient O(n) or O(n log n) solutions, depending on sorting requirements, verify that the chosen approach meets the problem’s constraints and performance requirements.\nScalability Consider how scalable the solution is for larger inputs. While the two-pointer approach is efficient, ensure that it can handle maximum input sizes within acceptable time and space constraints.\nExample: Finding Subarray with Maximum Sum Problem: Given an array of integers, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\ndef maxSubArray(nums): if not nums: return 0 max_sum = float('-inf') current_sum = 0 for num in nums: current_sum += num if current_sum \u003e max_sum: max_sum = current_sum if current_sum \u003c 0: current_sum = 0 return max_sum Initialization: Start with max_sum initialized to negative infinity (float('-inf')) to handle cases where all numbers are negative. Iterate through the array: Use a single pointer to traverse through the array and calculate the cumulative sum (current_sum). Update maximum sum: Update max_sum whenever current_sum exceeds it. Reset sum: Reset current_sum to zero if it becomes negative, ensuring the subarray starts fresh for potential maximum sums. For the input array nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4], the maximum sum of a contiguous subarray is 6, which corresponds to the subarray [4, -1, 2, 1].\nThis example demonstrates a scalable two-pointer-like approach for finding the maximum sum of a contiguous subarray, ensuring efficiency even with larger inputs.\n","wordCount":"1405","inLanguage":"en","image":"https://raghu-vijaykumar.github.io/blog/cover.png","datePublished":"2024-06-27T10:06:10+01:00","dateModified":"2024-06-27T10:06:10+01:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://raghu-vijaykumar.github.io/blog/posts/dsa/two-pointer/"},"publisher":{"@type":"Organization","name":"Raghu Vijaykumar","logo":{"@type":"ImageObject","url":"https://raghu-vijaykumar.github.io/blog/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://raghu-vijaykumar.github.io/blog/ accesskey=h title="Raghu Vijaykumar (Alt + H)"><img src=https://raghu-vijaykumar.github.io/apple-touch-icon.png alt aria-label=logo height=35>Raghu Vijaykumar</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://raghu-vijaykumar.github.io/blog/about/ title=about><span>about</span></a></li><li><a href=https://github.com/raghu-vijaykumar title=github><span>github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://raghu-vijaykumar.github.io/blog/posts/ title=posts><span>posts</span></a></li><li><a href=https://raghu-vijaykumar.github.io/blog/sponsor/ title=sponsor><span>sponsor</span></a></li><li><a href=https://raghu-vijaykumar.github.io/blog/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://raghu-vijaykumar.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://raghu-vijaykumar.github.io/blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">DSA - Two Pointer Approach - (In Progress)</h1><div class=post-meta><span title='2024-06-27 10:06:10 +0100 +0100'>June 27, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1405 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#characteristics-of-two-pointer-problems>Characteristics of Two-Pointer Problems</a></li><li><a href=#common-scenarios-for-two-pointer-approach>Common Scenarios for Two-Pointer Approach</a></li><li><a href=#steps-to-identify-and-apply-the-two-pointer-approach>Steps to Identify and Apply the Two-Pointer Approach</a><ul><li><a href=#check-if-sorting-helps>Check if Sorting Helps</a></li><li><a href=#look-for-pair-or-subarray-problems>Look for Pair or Subarray Problems</a></li><li><a href=#consider-the-traversal-directions>Consider the Traversal Directions</a></li><li><a href=#plan-pointer-movements>Plan Pointer Movements</a></li></ul></li><li><a href=#additional-considerations-for-two-pointer-approaches>Additional Considerations for Two-Pointer Approaches</a><ul><li><a href=#edge-cases>Edge Cases</a></li><li><a href=#multiple-pointers>Multiple Pointers</a></li><li><a href=#array-modification>Array Modification</a></li><li><a href=#time-complexity-analysis>Time Complexity Analysis</a></li><li><a href=#scalability>Scalability</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p><img loading=lazy src=./cover.png alt=Cover></p><p>The two-pointer approach is a powerful technique used to solve problems involving arrays or strings. Here are the key characteristics and criteria to identify if a problem can be effectively solved using the two-pointer approach:</p><h2 id=characteristics-of-two-pointer-problems>Characteristics of Two-Pointer Problems<a hidden class=anchor aria-hidden=true href=#characteristics-of-two-pointer-problems>#</a></h2><ol><li><p><strong>Sorted Input</strong>:</p><ul><li>The input array is sorted or can be easily sorted. Sorting often simplifies the problem and makes the two-pointer technique applicable.</li></ul></li><li><p><strong>Finding Pairs or Subarrays</strong>:</p><ul><li>The problem involves finding pairs, triplets, or subarrays that satisfy specific conditions, such as a target sum.</li></ul></li><li><p><strong>Linear or Quadratic Time Complexity</strong>:</p><ul><li>The problem can be solved in linear (O(n)) or quadratic (O(n^2)) time complexity, which are typical of two-pointer solutions.</li></ul></li><li><p><strong>Bidirectional Traversal</strong>:</p><ul><li>The solution requires traversing the array from both ends towards the center (or from the start towards the end using two pointers).</li></ul></li></ol><h2 id=common-scenarios-for-two-pointer-approach>Common Scenarios for Two-Pointer Approach<a hidden class=anchor aria-hidden=true href=#common-scenarios-for-two-pointer-approach>#</a></h2><ol><li><p><strong>Sum of Two Numbers</strong>:</p><ul><li>Problems where you need to find two numbers in an array that add up to a specific target.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>twoSum</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>nums</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>total</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>[</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>total</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span></code></pre></div></li><li><p><strong>Palindrome Checking</strong>:</p></li></ol><p><strong>Problem</strong>: Check if a string is a palindrome by comparing characters from both ends towards the center.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>isPalindrome</span><span class=p>(</span><span class=n>s</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>s</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>!=</span> <span class=n>s</span><span class=p>[</span><span class=n>right</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>True</span>
</span></span></code></pre></div><ol start=3><li><strong>Merging Sorted Arrays</strong>
<strong>Problem</strong>: Merge two sorted arrays into one sorted array.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>nums1</span><span class=p>,</span> <span class=n>nums2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums1</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>nums1</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>nums2</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nums1</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nums2</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>nums1</span><span class=p>[</span><span class=n>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>nums2</span><span class=p>[</span><span class=n>j</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><ol start=4><li><strong>Finding Subarrays with Specific Conditions</strong>
<strong>Problem</strong>: Find subarrays that satisfy certain conditions, such as a sum or product within a range.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>subarraySum</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>,</span> <span class=n>total</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>right</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>+=</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>total</span> <span class=o>&gt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>total</span> <span class=o>-=</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>total</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>[</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></div><h2 id=steps-to-identify-and-apply-the-two-pointer-approach>Steps to Identify and Apply the Two-Pointer Approach<a hidden class=anchor aria-hidden=true href=#steps-to-identify-and-apply-the-two-pointer-approach>#</a></h2><h3 id=check-if-sorting-helps>Check if Sorting Helps<a hidden class=anchor aria-hidden=true href=#check-if-sorting-helps>#</a></h3><ol><li><strong>Determine if sorting the array can simplify the problem</strong>:<ul><li>If the array is already sorted or can be sorted with (O(n \log n)) complexity, the two-pointer approach might be applicable.</li></ul></li></ol><h3 id=look-for-pair-or-subarray-problems>Look for Pair or Subarray Problems<a hidden class=anchor aria-hidden=true href=#look-for-pair-or-subarray-problems>#</a></h3><ol><li><strong>Identify if the problem involves finding pairs, triplets, or subarrays with specific properties</strong>:<ul><li>Typical examples include finding pairs that sum to a target, triplets that sum to zero, or the longest subarray with a given condition.</li></ul></li></ol><h3 id=consider-the-traversal-directions>Consider the Traversal Directions<a hidden class=anchor aria-hidden=true href=#consider-the-traversal-directions>#</a></h3><ol><li><strong>Determine if moving pointers inward from both ends or outward from the start can help find the solution</strong>:<ul><li>Check if you can eliminate impossible solutions by moving pointers in a structured manner.</li></ul></li></ol><h3 id=plan-pointer-movements>Plan Pointer Movements<a hidden class=anchor aria-hidden=true href=#plan-pointer-movements>#</a></h3><ol><li><strong>Define the conditions for moving the left and right pointers</strong>:<ul><li>For instance, if the current sum is less than the target, move the left pointer right to increase the sum.</li><li>If the current sum is greater than the target, move the right pointer left to decrease the sum.</li></ul></li></ol><h2 id=additional-considerations-for-two-pointer-approaches>Additional Considerations for Two-Pointer Approaches<a hidden class=anchor aria-hidden=true href=#additional-considerations-for-two-pointer-approaches>#</a></h2><h3 id=edge-cases>Edge Cases<a hidden class=anchor aria-hidden=true href=#edge-cases>#</a></h3><p>Always consider edge cases such as empty arrays, arrays with only one element, or arrays where all elements are identical. These cases might affect how you initialize and move the pointers.</p><h3 id=multiple-pointers>Multiple Pointers<a hidden class=anchor aria-hidden=true href=#multiple-pointers>#</a></h3><p>In some problems, especially those involving more complex conditions or more than two pointers (e.g., three pointers for <strong>k</strong>-Sum problems), adapting the basic two-pointer technique might be necessary.</p><h4 id=example-3-sum-problem>Example: 3-Sum Problem<a hidden class=anchor aria-hidden=true href=#example-3-sum-problem>#</a></h4><p><strong>Problem</strong>: Given an array <code>nums</code> of <code>n</code> integers, find all unique triplets <code>(a, b, c)</code> in the array such that they add up to zero.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>threeSum</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>nums</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>  <span class=c1># Step 1: Sort the array</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>2</span><span class=p>):</span>  <span class=c1># Step 2: Iterate through the array</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]:</span>  <span class=c1># Skip duplicate values</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>  <span class=c1># Step 3: Initialize two pointers</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>total</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span><span class=p>]</span>  <span class=c1># Calculate the sum of the triplet</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>total</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>res</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span><span class=p>],</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span><span class=p>]])</span>  <span class=c1># Add the triplet to the result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># Step 4: Move pointers and skip duplicates</span>
</span></span><span class=line><span class=cl>                <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span> <span class=ow>and</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>==</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span> <span class=ow>and</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span><span class=p>]</span> <span class=o>==</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>elif</span> <span class=n>total</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>  <span class=c1># Move the left pointer to the right to increase the sum</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>  <span class=c1># Move the right pointer to the left to decrease the sum</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span>
</span></span></code></pre></div><ul><li><p><strong>Sorting</strong>: Sort the array <code>nums</code> first to facilitate easier triplet sum calculation and skip duplicates.</p></li><li><p><strong>Iterating Through the Array</strong>: Use a loop to iterate through the array <code>nums</code>, fixing one element (<code>nums[i]</code>) at a time as the potential first element of the triplet.</p></li><li><p><strong>Initializing Pointers</strong>: For each fixed element <code>nums[i]</code>, initialize two pointers (<code>left</code> and <code>right</code>) to find the remaining two elements (<code>nums[left]</code> and <code>nums[right]</code>).</p></li><li><p><strong>Calculating Triplet Sum</strong>: Calculate the sum <code>total = nums[i] + nums[left] + nums[right]</code>. Depending on whether <code>total</code> is equal to, less than, or greater than zero, adjust the pointers to find the next potential triplet.</p></li><li><p><strong>Handling Duplicates</strong>: Skip over duplicate values of <code>nums[i]</code>, <code>nums[left]</code>, and <code>nums[right]</code> to ensure each triplet in the result <code>res</code> is unique.</p></li><li><p><strong>Moving Pointers</strong>: Adjust <code>left</code> and <code>right</code> pointers based on the calculated <code>total</code> to ensure progress towards finding all possible triplets that sum to zero.</p></li></ul><p>Given input array <code>nums = [-1, 0, 1, 2, -1, -4]</code>, the function <code>threeSum(nums)</code> will find all unique triplets <code>(a, b, c)</code> such that <code>a + b + c = 0</code>, resulting in: <code>[[-1, -1, 2], [-1, 0, 1]]</code></p><h3 id=array-modification>Array Modification<a hidden class=anchor aria-hidden=true href=#array-modification>#</a></h3><p>Be cautious when modifying the array during traversal, as it might affect subsequent pointer movements and the correctness of the solution. Make sure modifications are carefully handled.</p><h4 id=example-remove-duplicates-from-sorted-array>Example: Remove Duplicates from Sorted Array<a hidden class=anchor aria-hidden=true href=#example-remove-duplicates-from-sorted-array>#</a></h4><p><strong>Problem</strong>: Given a sorted array <code>nums</code>, remove the duplicates in-place such that each element appears only once and return the new length.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>removeDuplicates</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>slow</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>fast</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>fast</span><span class=p>]</span> <span class=o>!=</span> <span class=n>nums</span><span class=p>[</span><span class=n>slow</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>slow</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>nums</span><span class=p>[</span><span class=n>slow</span><span class=p>]</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>fast</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>slow</span> <span class=o>+</span> <span class=mi>1</span>
</span></span></code></pre></div><ul><li><strong>Initialization</strong>: Initialize two pointers, <code>slow</code> and <code>fast</code>, where <code>slow</code> points to the last unique element found and <code>fast</code> iterates through the array.</li><li><strong>Iterate through the array</strong>: Start iterating <code>fast</code> from the second element (<code>range(1, len(nums))</code>). Compare each element with the element at <code>slow</code>.</li><li><strong>Modify array in-place</strong>: If <code>nums[fast]</code> is different from <code>nums[slow]</code>, increment <code>slow</code> and update <code>nums[slow]</code> with <code>nums[fast]</code>. This modifies the array in-place to remove duplicates.</li><li><strong>Return the new length</strong>: After iterating through the array, <code>slow + 1</code> gives the length of the array with unique elements.</li></ul><p>This example demonstrates modifying the array (<code>nums</code>) in-place while using two pointers (<code>slow</code> and <code>fast</code>) to efficiently remove duplicates.</p><h3 id=time-complexity-analysis>Time Complexity Analysis<a hidden class=anchor aria-hidden=true href=#time-complexity-analysis>#</a></h3><p>While the two-pointer approach often provides efficient <strong>O(n)</strong> or <strong>O(n log n)</strong> solutions, depending on sorting requirements, verify that the chosen approach meets the problem&rsquo;s constraints and performance requirements.</p><h3 id=scalability>Scalability<a hidden class=anchor aria-hidden=true href=#scalability>#</a></h3><p>Consider how scalable the solution is for larger inputs. While the two-pointer approach is efficient, ensure that it can handle maximum input sizes within acceptable time and space constraints.</p><h4 id=example-finding-subarray-with-maximum-sum>Example: Finding Subarray with Maximum Sum<a hidden class=anchor aria-hidden=true href=#example-finding-subarray-with-maximum-sum>#</a></h4><p><strong>Problem</strong>: Given an array of integers, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>maxSubArray</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>max_sum</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>current_sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>num</span> <span class=ow>in</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current_sum</span> <span class=o>+=</span> <span class=n>num</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_sum</span> <span class=o>&gt;</span> <span class=n>max_sum</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>max_sum</span> <span class=o>=</span> <span class=n>current_sum</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_sum</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>current_sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>max_sum</span>
</span></span></code></pre></div><ul><li><strong>Initialization</strong>: Start with <code>max_sum</code> initialized to negative infinity (<code>float('-inf')</code>) to handle cases where all numbers are negative.</li><li><strong>Iterate through the array</strong>: Use a single pointer to traverse through the array and calculate the cumulative sum (<code>current_sum</code>).</li><li><strong>Update maximum sum</strong>: Update <code>max_sum</code> whenever <code>current_sum</code> exceeds it.</li><li><strong>Reset sum</strong>: Reset <code>current_sum</code> to zero if it becomes negative, ensuring the subarray starts fresh for potential maximum sums.</li></ul><p>For the input array <code>nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]</code>, the maximum sum of a contiguous subarray is <code>6</code>, which corresponds to the subarray <code>[4, -1, 2, 1]</code>.</p><p>This example demonstrates a scalable two-pointer-like approach for finding the maximum sum of a contiguous subarray, ensuring efficiency even with larger inputs.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://raghu-vijaykumar.github.io/blog/tags/algorithms/>Algorithms</a></li><li><a href=https://raghu-vijaykumar.github.io/blog/tags/data-structures/>Data-Structures</a></li><li><a href=https://raghu-vijaykumar.github.io/blog/tags/two-pointer/>Two-Pointer</a></li><li><a href=https://raghu-vijaykumar.github.io/blog/tags/dsa/>DSA</a></li><li><a href=https://raghu-vijaykumar.github.io/blog/tags/array/>Array</a></li></ul><nav class=paginav><a class=prev href=https://raghu-vijaykumar.github.io/blog/posts/dsa/sliding-window/><span class=title>« Prev</span><br><span>DSA - Sliding Window - (In Progress)</span>
</a><a class=next href=https://raghu-vijaykumar.github.io/blog/posts/architecture/product-template/><span class=title>Next »</span><br><span>Product Template - Documentation</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://raghu-vijaykumar.github.io/blog/>Raghu Vijaykumar</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>