<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Docs on Raghu Vijaykumar</title>
    <link>https://raghu-vijaykumar.github.io/blog/docs/</link>
    <description>Recent content in Docs on Raghu Vijaykumar</description>
    <image>
      <title>Raghu Vijaykumar</title>
      <url>https://raghu-vijaykumar.github.io/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://raghu-vijaykumar.github.io/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.127.0</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 Aug 2024 14:46:15 +0000</lastBuildDate>
    <atom:link href="https://raghu-vijaykumar.github.io/blog/docs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Adapter Pattern</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/adapter/readme/</link>
      <pubDate>Sat, 24 Aug 2024 14:46:15 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/adapter/readme/</guid>
      <description>The Adapter Design Pattern allows objects with incompatible interfaces to work together. It acts as a bridge between two interfaces, adapting one interface to another that the client expects.
Problem Statement When building software systems, it is common to encounter situations where an existing class or component has an interface that does not match the interface required by a specific client. Modifying the existing class to meet the new interface could lead to breaking other parts of the system or complicating the code unnecessarily.</description>
    </item>
    <item>
      <title>Bridge Pattern</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/bridge/readme/</link>
      <pubDate>Sat, 24 Aug 2024 14:46:15 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/bridge/readme/</guid>
      <description>The Bridge design pattern is used to decouple an abstraction from its implementation, allowing both to vary independently. This pattern is particularly useful when dealing with a potential &amp;ldquo;Cartesian product complexity explosion,&amp;rdquo; which occurs when multiple abstractions and implementations multiply the number of classes needed.
Code Structure Renderer Interface: Renderer: An abstract base class that defines the method render_circle(radius). This method serves as the interface for rendering shapes. Concrete Implementations of Renderer: VectorRenderer: A concrete implementation of Renderer.</description>
    </item>
    <item>
      <title>Builder Pattern</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/builder/readme/</link>
      <pubDate>Sat, 24 Aug 2024 14:46:15 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/builder/readme/</guid>
      <description>The Builder Design Pattern is a creational pattern that provides a way to construct complex objects step by step. Unlike the abstract factory pattern, the builder pattern is more about constructing a single object, rather than families of objects.
Why Use the Builder Pattern? The Builder pattern is particularly useful when:
Complex Object Construction: When an object requires multiple steps to construct, where each step may involve different parts of the object.</description>
    </item>
    <item>
      <title>Composite Pattern</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/composite/readme/</link>
      <pubDate>Sat, 24 Aug 2024 14:46:15 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/composite/readme/</guid>
      <description>The Composite Design Pattern is a structural design pattern that allows you to treat individual objects and compositions of objects uniformly. This pattern provides a way to group objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly, thereby simplifying the client code.
Motivation In software development, there are scenarios where you need to work with both individual objects and collections of objects.</description>
    </item>
    <item>
      <title>Decorator Pattern</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/decorator/readme/</link>
      <pubDate>Sat, 24 Aug 2024 14:46:15 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/decorator/readme/</guid>
      <description>The Decorator Pattern is a structural design pattern used to add additional behaviors or responsibilities to objects dynamically. Unlike subclassing, where additional functionality is achieved through inheritance, the decorator pattern allows the augmentation of an objectâ€™s behavior without modifying its structure or the need for inheritance. This promotes adherence to the Open/Closed Principle and Single Responsibility Principle in software design.
Motivation The main motivation for using the decorator pattern is to add features or functionality to existing objects in a flexible and reusable way.</description>
    </item>
    <item>
      <title>Factory Pattern</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/factory/readme/</link>
      <pubDate>Sat, 24 Aug 2024 14:46:15 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/factory/readme/</guid>
      <description>Factory Method and Factory Class Implementation The Factory Method and the Factory Class design patterns, which are essential for creating objects in a way that is both flexible and adheres to object-oriented principles like the Single Responsibility Principle and Open/Closed Principle.
The discussion begins by introducing a simple Point class and evolves into explaining how to initialize points using both Cartesian and Polar coordinates while maintaining clean and understandable code.</description>
    </item>
    <item>
      <title>Prototype Pattern</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/prototype/readme/</link>
      <pubDate>Sat, 24 Aug 2024 14:46:15 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/prototype/readme/</guid>
      <description>The prototype design pattern is a creational design pattern that allows an object to be cloned, creating new instances by copying an existing object, known as the prototype. This pattern is particularly useful when creating a new object from scratch is resource-intensive or when an object should be replicated with slight modifications.
Motivation In many real-world scenarios, objects are not designed from scratch but are built upon existing designs. The prototype pattern follows this approach by allowing an existing object to be duplicated and then customized without affecting the original object.</description>
    </item>
    <item>
      <title>Singleton Pattern</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/singleton/readme/</link>
      <pubDate>Sat, 24 Aug 2024 14:46:15 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/design-patterns/singleton/readme/</guid>
      <description>The singleton design pattern ensures that a class has only one instance and provides a global point of access to that instance. This pattern is often used when exactly one object is needed to coordinate actions across the system, such as when managing shared resources like databases or configuration settings.
Motivation The singleton pattern is motivated by scenarios where certain classes should only be instantiated once. Common examples include:
Database Connections: You typically only want one instance of a database connection throughout the lifecycle of an application to avoid redundant connections and ensure consistent access to the data.</description>
    </item>
    <item>
      <title>Solid Principles</title>
      <link>https://raghu-vijaykumar.github.io/blog/docs/system-design/solid-principles/readme/</link>
      <pubDate>Sat, 24 Aug 2024 14:46:15 +0000</pubDate>
      <guid>https://raghu-vijaykumar.github.io/blog/docs/system-design/solid-principles/readme/</guid>
      <description>Single Responsibility Principle (SRP) The Single Responsibility Principle (SRP) is one of the five SOLID principles of object-oriented design and programming. It states that a class, module, or function should have only one reason to change, meaning it should have only one responsibility or job. This principle promotes the idea that a class should only have one reason to exist, encapsulating all the functionality related to that responsibility.
Key Points of Single Responsibility Principle</description>
    </item>
  </channel>
</rss>
